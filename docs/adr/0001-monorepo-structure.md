
# ADR-0001: Выбор структуры монорепозитория

**Статус:** Accepted  
**Дата:** 2025-10-16  
**Авторы:** @Serg2206  

## Контекст и проблема

Проект SSVproff состоит из нескольких взаимосвязанных компонентов:
- FastAPI backend (Python)
- Next.js frontend (TypeScript)
- Документация (MkDocs)
- Скрипты автоматизации
- Метаданные и схемы

Необходимо определить оптимальную структуру для организации кода, обеспечивающую:
- Удобство разработки
- Простоту CI/CD
- Переиспользование кода
- Управление зависимостями

## Рассмотренные варианты

### Вариант 1: Монорепозиторий (Monorepo)

Все компоненты в одном репозитории с четкой структурой директорий.

```
SSVproff/
├── api/          # FastAPI backend
├── web/          # Next.js frontend
├── docs/         # MkDocs документация
├── flows/        # Скрипты автоматизации
├── data-meta/    # Схемы данных
└── .github/      # CI/CD конфигурации
```

**Преимущества:**
- ✅ Единая версионность всех компонентов
- ✅ Атомарные изменения в нескольких модулях
- ✅ Упрощённый CI/CD (одна pipeline для всех)
- ✅ Лёгкое переиспользование кода и типов
- ✅ Проще управление зависимостями
- ✅ Единая история изменений

**Недостатки:**
- ❌ Больший размер репозитория
- ❌ Сложнее настроить selective CI (нужны path filters)
- ❌ Требует дисциплины в организации кода

### Вариант 2: Полирепозиторий (Polyrepo)

Каждый компонент в отдельном репозитории.

```
ssvproff-api/          # Отдельный репозиторий
ssvproff-web/          # Отдельный репозиторий  
ssvproff-docs/         # Отдельный репозиторий
```

**Преимущества:**
- ✅ Полная изоляция модулей
- ✅ Независимые версии и релизы
- ✅ Проще управление доступом

**Недостатки:**
- ❌ Сложнее синхронизировать изменения
- ❌ Дублирование конфигураций CI/CD
- ❌ Сложнее переиспользование кода
- ❌ Фрагментированная история изменений
- ❌ Больше overhead на поддержку

### Вариант 3: Monorepo с workspace tools

Монорепо с использованием специализированных инструментов (Nx, Turborepo, Lerna).

**Преимущества:**
- ✅ Все плюсы монорепо
- ✅ Оптимизированные сборки
- ✅ Кэширование между проектами

**Недостатки:**
- ❌ Дополнительная зависимость
- ❌ Кривая обучения
- ❌ Оверхед для небольшого проекта

## Принятое решение

**Выбран вариант:** Монорепозиторий (Вариант 1)

**Обоснование:**

1. **Размер проекта:** SSVproff - это средний проект с 3-5 основными модулями. Монорепо идеально подходит для такого масштаба.

2. **Связанность модулей:** API и Web тесно интегрированы, часто изменения в API требуют изменений во frontend. Монорепо позволяет делать атомарные изменения.

3. **Простота CI/CD:** Один `.github/workflows/` с path filters проще настроить и поддерживать, чем несколько отдельных CI конфигураций.

4. **Team size:** Для команды из 1-5 разработчиков монорепо не создаёт проблем, а наоборот упрощает работу.

5. **Документация:** Держать документацию рядом с кодом удобнее для синхронизации.

## Последствия

### Положительные

- Упрощённая разработка: клонируем один репозиторий и имеем всё необходимое
- Атомарные PR: изменения в API и Web в одном Pull Request
- Единая история: легко отследить связь изменений между модулями
- Простота навигации: вся кодовая база в одном месте

### Негативные

- Размер репозитория вырастет со временем (митигация: Git LFS для больших файлов)
- Нужна настройка CI path filters (уже реализовано в `.github/workflows/ci.yml`)

### Риски

- **Риск:** Случайные изменения в других модулях
  - **Митигация:** CODEOWNERS, обязательные code review, pre-commit hooks
  
- **Риск:** Медленный CI при росте проекта
  - **Митигация:** Path filters, selective runs, кэширование зависимостей

## Связи

- Первый ADR, определяет базовую структуру проекта

## Примечания

Структура директорий:
- `/api` - FastAPI backend с собственным `pyproject.toml`
- `/web` - Next.js frontend с `package.json`
- `/docs` - MkDocs документация
- `/flows` - Скрипты автоматизации (rclone, DVC)
- `/data-meta` - Схемы данных и миграции
- `/` - Корневой `Makefile`, `package.json` для monorepo-level инструментов

Инструменты монорепо:
- Path filters в GitHub Actions для оптимизации CI
- Корневой `package.json` с husky для pre-commit hooks
- Makefile для унифицированных команд
